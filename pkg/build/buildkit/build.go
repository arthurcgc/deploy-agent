// Copyright 2022 tsuru authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package buildkit

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strconv"
	"strings"

	"github.com/moby/buildkit/client"
	"github.com/moby/buildkit/frontend/dockerfile/builder"
	"github.com/moby/buildkit/session"
	"github.com/moby/buildkit/session/auth/authprovider"
	"github.com/moby/buildkit/session/secrets"
	"github.com/moby/buildkit/session/secrets/secretsprovider"
	"github.com/moby/buildkit/util/progress/progresswriter"
	"golang.org/x/sync/errgroup"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"gopkg.in/yaml.v3"

	pb "github.com/tsuru/deploy-agent/api/v1alpha1"
	"github.com/tsuru/deploy-agent/pkg/build"
)

var _ build.Builder = (*BuildKit)(nil)

type BuildKitOptions struct {
	TempDir string
}

type BuildKit struct {
	cli  *client.Client
	opts BuildKitOptions
}

func NewBuildKit(c *client.Client, opts BuildKitOptions) *BuildKit {
	return &BuildKit{cli: c, opts: opts}
}

func (b *BuildKit) Build(ctx context.Context, r *pb.BuildRequest, tc *pb.TsuruConfig, w io.Writer) error {
	if err := ctx.Err(); err != nil {
		return err
	}

	tmpDir, cleanFunc, err := generateBuildLocalDir(ctx, b.opts.TempDir, r, tc, bytes.NewBuffer(r.Data))
	if err != nil {
		return err
	}
	defer cleanFunc()

	pw, err := progresswriter.NewPrinter(context.Background(), w.(*build.BuildResponseOutputWriter), "plain") //nolint - using an empty context intentionally
	if err != nil {
		return err
	}

	eg, _ := errgroup.WithContext(ctx)

	eg.Go(func() error {
		var secrets secrets.SecretStore
		secrets, err = secretsprovider.NewStore([]secretsprovider.Source{{
			ID:       "tsuru-app-envvars",
			FilePath: filepath.Join(tmpDir, "envs.sh"),
		}})
		if err != nil {
			return err
		}

		var (
			insecureRegistry bool        // disabled by default
			pushImage        bool = true // enabled by default
		)
		if pots := r.PushOptions; pots != nil {
			pushImage = !pots.Disable
			insecureRegistry = pots.InsecureRegistry
		}

		opts := client.SolveOpt{
			LocalDirs: map[string]string{
				"context":    tmpDir,
				"dockerfile": tmpDir,
			},
			Exports: []client.ExportEntry{
				{
					Type: client.ExporterImage,
					Attrs: map[string]string{
						"name":              strings.Join(r.DestinationImages, ","),
						"push":              strconv.FormatBool(pushImage),
						"registry.insecure": strconv.FormatBool(insecureRegistry),
					},
				},
			},
			Session: []session.Attachable{
				authprovider.NewDockerAuthProvider(w),
				secretsprovider.NewSecretProvider(secrets),
			},
		}
		_, err = b.cli.Build(ctx, opts, "deploy-agent", builder.Build, progresswriter.ResetTime(pw).Status())
		return err
	})

	eg.Go(func() error {
		<-pw.Done()
		return pw.Err()
	})

	if err = eg.Wait(); err != nil {
		return err
	}

	return nil
}

func (b *BuildKit) FindTsuruAppFiles(ctx context.Context, r *pb.BuildRequest) (*pb.TsuruConfig, error) {
	if err := ctx.Err(); err != nil {
		return nil, err
	}

	appFiles, err := build.ExtractTsuruAppFilesFromAppSourceContext(ctx, bytes.NewBuffer(r.Data))
	if err != nil {
		return nil, err
	}

	return &pb.TsuruConfig{
		Procfile:  appFiles.Procfile,
		TsuruYaml: appFiles.TsuruYaml,
	}, nil
}

func generateBuildLocalDir(ctx context.Context, baseDir string, req *pb.BuildRequest, tsuruAppFiles *pb.TsuruConfig, appData io.Reader) (string, func(), error) {
	noopFunc := func() {}

	if err := ctx.Err(); err != nil {
		return "", noopFunc, err
	}

	contextRootDir, err := os.MkdirTemp(baseDir, "deploy-agent-*")
	if err != nil {
		return "", noopFunc, status.Errorf(codes.Internal, "failed to create temp dir: %s", err)
	}

	eg, _ := errgroup.WithContext(ctx)

	eg.Go(func() error {
		dockerfile, nerr := os.Create(filepath.Join(contextRootDir, "Dockerfile"))
		if nerr != nil {
			return status.Errorf(codes.Internal, "cannot create Dockerfile in %s: %s", contextRootDir, nerr)
		}
		defer dockerfile.Close()

		return generateContainerfile(dockerfile, req.SourceImage, tsuruAppFiles)
	})

	eg.Go(func() error {
		appArchive, nerr := os.Create(filepath.Join(contextRootDir, "application.tar.gz"))
		if nerr != nil {
			return status.Errorf(codes.Internal, "cannot create application archive: %s", nerr)
		}
		defer appArchive.Close()

		_, nerr = io.Copy(appArchive, appData)
		return nerr
	})

	eg.Go(func() error {
		envsFile, nerr := os.Create(filepath.Join(contextRootDir, "envs.sh"))
		if nerr != nil {
			return nerr
		}
		defer envsFile.Close()

		fmt.Fprintln(envsFile, "# File containing the env vars of Tsuru app. Generated by deploy-agent.")

		if req.App == nil {
			return nil
		}

		for k, v := range req.App.EnvVars {
			fmt.Fprintf(envsFile, "%s=%q\n", k, v)
		}

		return nil
	})

	if err = eg.Wait(); err != nil {
		return "", noopFunc, err
	}

	return contextRootDir, func() { os.RemoveAll(contextRootDir) }, nil
}

func generateContainerfile(w io.Writer, image string, tsuruAppFiles *pb.TsuruConfig) error {
	var tsuruYaml build.TsuruYamlData
	if tsuruAppFiles != nil {
		if err := yaml.Unmarshal([]byte(tsuruAppFiles.TsuruYaml), &tsuruYaml); err != nil {
			return err
		}
	}

	var buildHooks []string
	if hooks := tsuruYaml.Hooks; hooks != nil {
		buildHooks = hooks.Build
	}

	dockerfile, err := build.BuildContainerfile(build.BuildContainerfileParams{
		Image:      image,
		BuildHooks: buildHooks,
	})
	if err != nil {
		return err
	}

	_, err = io.WriteString(w, dockerfile)
	return err
}
